# zqlc

Type-safe SQL code generation for Zig. Reads `.sql` files, introspects a live PostgreSQL database, and generates Zig structs and query functions.

## How it works

1. Discovers `.sql` files in `src/**/sql/` directories
2. Parses SQL annotations (`-- name: QueryName :kind`)
3. Connects to PostgreSQL and introspects parameter/column types
4. Generates a `sql.zig` file in the parent directory of each `sql/` folder

## Requirements

- Zig 0.15+
- A running PostgreSQL database

## Build

```sh
zig build
```

## Usage

Set `DATABASE_URL` as an environment variable or in a `.env` file:

```sh
# Environment variable
DATABASE_URL=postgresql://user:password@localhost:5432/mydb zqlc generate

# Or create a .env file in the project root
echo 'DATABASE_URL=postgresql://user:password@localhost:5432/mydb' > .env
zqlc generate
```

### Commands

| Command | Description |
|---------|-------------|
| `generate` | Generate Zig code from SQL files (default) |
| `check` | Check if generated files are up to date |

### Options

| Option | Description |
|--------|-------------|
| `--src <dir>` | Directory to scan for `sql/` subdirectories (default: `{project_root}/src`) |
| `--dest <dir>` | Output directory for generated files (mirrors `--src` structure) |
| `-h`, `--help` | Show help message |
| `-v`, `--version` | Show version |

When `--dest` is set, the directory structure from `--src` is mirrored into `--dest`, and two additional files are generated:

- **`root.zig`** — re-exports all generated `sql.zig` modules
- **`helper.zig`** — shared type definitions (e.g., `Timestamp`, PG enum types)

```sh
# Scan queries/ for SQL, output generated Zig to src/db/
zqlc --src queries/ --dest src/db/ generate
```

```
queries/                  src/db/
  users/sql/                users/sql.zig
    get_user.sql            posts/sql.zig
  posts/sql/                root.zig
    create_post.sql         helper.zig
```

### Check mode

Use `check` in CI to detect drift between SQL files and generated code:

```sh
zqlc check
```

Exits with code 1 if any `sql.zig` file is out of date.

## SQL annotations

Annotate your SQL files with `-- name: QueryName :kind`:

| Kind | Return type | Description |
|------|-------------|-------------|
| `:one` | `?Row` | Returns one row or null |
| `:many` | `[]Row` | Returns zero or more rows |
| `:exec` | `void` | Execute, no return value |
| `:execrows` | `?usize` | Returns affected row count |

## Directory convention

```
src/
  users/
    sql/
      find_user.sql
      list_users.sql
    sql.zig          <-- generated
  posts/
    sql/
      create_post.sql
    sql.zig          <-- generated
```

Each `sql/` directory produces one `sql.zig` in its parent directory.

## Example

### SQL file (`src/users/sql/find_user.sql`)

```sql
-- name: FindUserById :one
SELECT id, name, email
FROM users
WHERE id = $1;
```

### Generated Zig (`src/users/sql.zig`)

```zig
// Code generated by zqlc. DO NOT EDIT.

const std = @import("std");
const pg = @import("pg");

pub const FindUserByIdRow = struct {
    id: i32,
    name: []const u8,
    email: []const u8,
};

pub fn findUserById(pool: *pg.Pool, allocator: std.mem.Allocator, id: i32) !?FindUserByIdRow {
    if (try pool.row(
        \\ SELECT id, name, email
        \\ FROM users
        \\ WHERE id = $1
    , .{id})) |row| {
        defer row.deinit();
        return .{
            .id = row.get(i32, 0),
            .name = try allocator.dupe(u8, row.get([]u8, 1)),
            .email = try allocator.dupe(u8, row.get([]u8, 2)),
        };
    }
    return null;
}
```

### Using the generated code

```zig
const sql = @import("sql.zig");

pub fn handler(pool: *pg.Pool, allocator: std.mem.Allocator) !void {
    if (try sql.findUserById(pool, allocator, 42)) |user| {
        std.debug.print("Found: {s}\n", .{user.name});
    }
}
```

## Params struct

When a query has 4 or more parameters, a `Params` struct is generated:

```sql
-- name: UpdateUser :one
UPDATE users SET name = $2, email = $3, is_active = $4
WHERE id = $1
RETURNING id, name, email;
```

Generates:

```zig
pub const UpdateUserParams = struct {
    id: i32,
    name: []const u8,
    email: []const u8,
    is_active: bool,
};

pub fn updateUser(pool: *pg.Pool, allocator: std.mem.Allocator, params: UpdateUserParams) !?UpdateUserRow {
    // ...
}
```

## Type mappings

| PostgreSQL | Zig |
|------------|-----|
| `boolean` | `bool` |
| `smallint` | `i16` |
| `integer` | `i32` |
| `bigint` | `i64` |
| `real` | `f32` |
| `double precision`, `numeric` | `f64` |
| `text`, `varchar` | `[]const u8` |
| `bytea` | `[]const u8` |
| `uuid` | `[]const u8` |
| `json`, `jsonb` | `[]const u8` |
| `timestamp`, `timestamptz` | `i64` |
| `date` | `i32` |
| `time`, `timetz` | `i64` |
| `interval` | `[]const u8` |

Nullable columns are wrapped with `?` (e.g., `?i32`, `?[]const u8`).
