# zqlc

Type-safe SQL code generation for Zig — like [sqlc](https://sqlc.dev), but for Zig.

Reads `.sql` files, introspects a live PostgreSQL database, and generates Zig structs and query functions.

## Requirements

- Zig 0.15+
- A running PostgreSQL database

## Install

```sh
git clone https://github.com/ankitpatial/zqlc.git
cd zqlc
zig build -Doptimize=.ReleaseSafe
# copy zig-out/bin/zqlc somewhere on your PATH
```

## Quick start

**1. Set your database connection**

```sh
export DATABASE_URL=postgresql://user:password@localhost:5432/mydb
```

Or create a `.env` file in your project root:

```
DATABASE_URL=postgresql://user:password@localhost:5432/mydb
```

**2. Write a SQL file**

Place it inside a `db/sql/` subdirectory:

```sql
-- db/sql/user.sql

-- name: FindById :one
SELECT id, name, email
FROM users
WHERE id = $1;
```

**3. Generate**

```sh
zqlc generate --src db/sql/ --dest db/query/
```

This produces `db/query/user.zig` with type-safe structs and functions.

**4. Use the generated code**

```zig
const query = @import("db/query/root.zig");

pub fn handler(pool: *pg.Pool, allocator: std.mem.Allocator) !void {
    if (try query.user.findById(pool, allocator, 42)) |user| {
        std.debug.print("Found: {s}\n", .{user.name});
    }
}
```

## CLI reference

```
zqlc <command> --src <dir> --dest <dir>
```

### Commands

| Command    | Description                                  |
|------------|----------------------------------------------|
| `generate` | Generate Zig code from SQL files             |
| `check`    | Check if generated files are up to date      |

### Options

| Option         | Description                                                              |
|----------------|--------------------------------------------------------------------------|
| `--src <dir>`  | **(required)** Directory containing `.sql` files                         |
| `--dest <dir>` | **(required)** Output directory for generated files                      |
| `-h, --help`   | Show help                                                                |
| `-v, --version`| Show version                                                             |

### Examples

```sh
# Generate Zig code
zqlc generate --src db/sql/ --dest db/query/

# CI: fail if generated code is stale
zqlc check --src db/sql/ --dest db/query/
```

### Output

The directory structure from `--src` is mirrored into `--dest`, and two additional files are generated:

- **`root.zig`** — re-exports all generated `sql.zig` modules
- **`helper.zig`** — shared type definitions (e.g., `Timestamp`, PG enum types)

```
queries/                  src/db/
  users/sql/                users/sql.zig
    get_user.sql            posts/sql.zig
  posts/sql/                root.zig
    create_post.sql         helper.zig
```

## SQL annotations

Each SQL file must have an annotation comment on the line before the query:

```sql
-- name: QueryName :kind
```

| Kind        | Return type | Description                  |
|-------------|-------------|------------------------------|
| `:one`      | `?Row`      | Returns one row or null      |
| `:many`     | `[]Row`     | Returns zero or more rows    |
| `:exec`     | `void`      | Execute, no return value     |
| `:execrows` | `?usize`    | Returns affected row count   |


## Generated code example

Given this SQL:

```sql
-- name: FindUserById :one
SELECT id, name, email
FROM users
WHERE id = $1;
```

`zqlc` generates:

```zig
// Code generated by zqlc. DO NOT EDIT.

const std = @import("std");
const pg = @import("pg");

pub const FindUserByIdRow = struct {
    id: i32,
    name: []const u8,
    email: []const u8,
};

pub fn findUserById(pool: *pg.Pool, allocator: std.mem.Allocator, id: i32) !?FindUserByIdRow {
    if (try pool.row(
        \\ SELECT id, name, email
        \\ FROM users
        \\ WHERE id = $1
    , .{id})) |row| {
        defer row.deinit();
        return .{
            .id = row.get(i32, 0),
            .name = try allocator.dupe(u8, row.get([]u8, 1)),
            .email = try allocator.dupe(u8, row.get([]u8, 2)),
        };
    }
    return null;
}
```

### Params struct

When a query has 4 or more parameters, a `Params` struct is generated instead of positional arguments:

```sql
-- name: UpdateUser :one
UPDATE users SET name = $2, email = $3, is_active = $4
WHERE id = $1
RETURNING id, name, email;
```

```zig
pub const UpdateUserParams = struct {
    id: i32,
    name: []const u8,
    email: []const u8,
    is_active: bool,
};

pub fn updateUser(pool: *pg.Pool, allocator: std.mem.Allocator, params: UpdateUserParams) !?UpdateUserRow {
    // ...
}
```

## Type mappings

| PostgreSQL                     | Zig            |
|--------------------------------|----------------|
| `boolean`                      | `bool`         |
| `smallint`                     | `i16`          |
| `integer`                      | `i32`          |
| `bigint`                       | `i64`          |
| `real`                         | `f32`          |
| `double precision`, `numeric`  | `f64`          |
| `text`, `varchar`              | `[]const u8`   |
| `bytea`                        | `[]const u8`   |
| `uuid`                         | `[]const u8`   |
| `json`, `jsonb`                | `[]const u8`   |
| `timestamp`, `timestamptz`     | `i64`          |
| `date`                         | `i32`          |
| `time`, `timetz`               | `i64`          |
| `interval`                     | `[]const u8`   |

Nullable columns are wrapped with `?` (e.g., `?i32`, `?[]const u8`).
