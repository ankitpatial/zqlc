const std = @import("std");
const types = @import("types.zig");
const introspect = @import("introspect.zig");
const project = @import("project.zig");

const header = "// Code generated by zqlc. DO NOT EDIT.\n";
const params_struct_threshold = 3;

/// Generate Zig source code from a list of typed queries.
/// When helper_rel_path is set, shared types (Timestamp, enums) are imported from the helper
/// module instead of being defined inline.
pub fn generate(allocator: std.mem.Allocator, queries: []const introspect.TypedQuery, helper_rel_path: ?[]const u8) ![]const u8 {
    var buf: std.ArrayList(u8) = .empty;
    errdefer buf.deinit(allocator);

    try buf.appendSlice(allocator, header);
    try buf.append(allocator, '\n');

    // Scan for needed helper types
    var needs_timestamp = false;
    var enum_types = std.StringHashMap(types.ZigType.EnumInfo).init(allocator);
    defer enum_types.deinit();

    for (queries) |q| {
        for (q.params) |p| scanTypeNeeds(p.zig_type, &needs_timestamp, &enum_types) catch {};
        for (q.columns) |c| scanTypeNeeds(c.zig_type, &needs_timestamp, &enum_types) catch {};
    }

    // Imports
    if (queries.len > 0) {
        try buf.appendSlice(allocator, "const std = @import(\"std\");\n");
        try buf.appendSlice(allocator, "const pg = @import(\"pg\");\n");
        if (helper_rel_path) |hrp| {
            try appendFmt(allocator, &buf, "const helper = @import(\"{s}\");\n", .{hrp});
        }
        try buf.append(allocator, '\n');
    }

    if (helper_rel_path == null) {
        // Timestamp alias (inline when no helper)
        if (needs_timestamp) {
            try buf.appendSlice(allocator, "pub const Timestamp = i64;\n\n");
        }

        // Enum type definitions (inline when no helper)
        var enum_iter = enum_types.iterator();
        while (enum_iter.next()) |entry| {
            const info = entry.value_ptr.*;
            const pascal_name = try snakeToPascal(allocator, info.name);
            defer allocator.free(pascal_name);

            try appendFmt(allocator, &buf, "pub const {s} = enum {{\n", .{pascal_name});
            for (info.variants) |variant| {
                const zig_variant = try sanitizeEnumVariant(allocator, variant);
                defer allocator.free(zig_variant);
                try appendFmt(allocator, &buf, "    {s},\n", .{zig_variant});
            }
            try buf.appendSlice(allocator, "};\n\n");
        }
    }

    const use_helper = helper_rel_path != null;

    // Per-query: doc comment, row struct, execution function
    for (queries) |q| {
        // Doc comment
        if (q.comment) |comment| {
            var lines = std.mem.splitScalar(u8, comment, '\n');
            while (lines.next()) |line| {
                try appendFmt(allocator, &buf, "/// {s}\n", .{line});
            }
        }

        // Row struct (only for queries that return columns)
        if (q.columns.len > 0) {
            const struct_name = try queryStructName(allocator, q.name, "Row");
            defer allocator.free(struct_name);

            try appendFmt(allocator, &buf, "pub const {s} = struct {{\n", .{struct_name});
            for (q.columns) |col| {
                try buf.appendSlice(allocator, "    ");
                try buf.appendSlice(allocator, col.name);
                try buf.appendSlice(allocator, ": ");
                if (col.nullable) try buf.append(allocator, '?');
                try appendPgFieldType(allocator, &buf, col.zig_type, use_helper);
                try buf.appendSlice(allocator, ",\n");
            }
            try buf.appendSlice(allocator, "};\n\n");
        }

        // Params struct (only for queries with more than threshold params)
        if (q.params.len > params_struct_threshold) {
            const params_struct_name = try queryStructName(allocator, q.name, "Params");
            defer allocator.free(params_struct_name);
            try appendFmt(allocator, &buf, "pub const {s} = struct {{\n", .{params_struct_name});
            for (q.params) |param| {
                try buf.appendSlice(allocator, "    ");
                try buf.appendSlice(allocator, param.name);
                try buf.appendSlice(allocator, ": ");
                try appendPgFieldType(allocator, &buf, param.zig_type, use_helper);
                try buf.appendSlice(allocator, ",\n");
            }
            try buf.appendSlice(allocator, "};\n\n");
        }

        // Execution function
        switch (q.kind) {
            .one => try emitOneFunction(allocator, &buf, q, use_helper),
            .many => try emitManyFunction(allocator, &buf, q, use_helper),
            .exec => try emitExecFunction(allocator, &buf, q, use_helper),
            .execrows => try emitExecRowsFunction(allocator, &buf, q, use_helper),
        }
    }

    return buf.toOwnedSlice(allocator);
}

/// Generate helper.zig containing shared type definitions (Timestamp, enums)
/// used across all generated sql.zig modules.
pub fn generateHelper(allocator: std.mem.Allocator, all_queries: []const []const introspect.TypedQuery) ![]const u8 {
    var buf: std.ArrayList(u8) = .empty;
    errdefer buf.deinit(allocator);

    try buf.appendSlice(allocator, header);
    try buf.append(allocator, '\n');

    // Scan all queries for shared type needs
    var needs_timestamp = false;
    var enum_types = std.StringHashMap(types.ZigType.EnumInfo).init(allocator);
    defer enum_types.deinit();

    for (all_queries) |queries| {
        for (queries) |q| {
            for (q.params) |p| scanTypeNeeds(p.zig_type, &needs_timestamp, &enum_types) catch {};
            for (q.columns) |c| scanTypeNeeds(c.zig_type, &needs_timestamp, &enum_types) catch {};
        }
    }

    if (needs_timestamp) {
        try buf.appendSlice(allocator, "pub const Timestamp = i64;\n");
    }

    // Collect and sort enum names for deterministic output
    var enum_names: std.ArrayList([]const u8) = .empty;
    defer enum_names.deinit(allocator);
    {
        var iter = enum_types.iterator();
        while (iter.next()) |entry| {
            try enum_names.append(allocator, entry.key_ptr.*);
        }
    }
    std.mem.sort([]const u8, enum_names.items, {}, struct {
        fn lessThan(_: void, a: []const u8, b: []const u8) bool {
            return std.mem.order(u8, a, b) == .lt;
        }
    }.lessThan);

    for (enum_names.items) |name| {
        const info = enum_types.get(name).?;
        const pascal_name = try snakeToPascal(allocator, info.name);
        defer allocator.free(pascal_name);

        if (needs_timestamp or buf.items.len > header.len + 1) try buf.append(allocator, '\n');
        try appendFmt(allocator, &buf, "pub const {s} = enum {{\n", .{pascal_name});
        for (info.variants) |variant| {
            const zig_variant = try sanitizeEnumVariant(allocator, variant);
            defer allocator.free(zig_variant);
            try appendFmt(allocator, &buf, "    {s},\n", .{zig_variant});
        }
        try buf.appendSlice(allocator, "};\n");
    }

    return buf.toOwnedSlice(allocator);
}

/// Generate root.zig that re-exports all generated zig modules.
pub fn generateRoot(allocator: std.mem.Allocator, groups: []const project.SqlFileGroup) ![]const u8 {
    var buf: std.ArrayList(u8) = .empty;
    errdefer buf.deinit(allocator);

    try buf.appendSlice(allocator, header);
    try buf.append(allocator, '\n');

    for (groups) |group| {
        // Derive module name from the file stem of rel_path
        // e.g., "delete.zig" → "delete", "user/abc.zig" → "abc"
        const basename = std.fs.path.stem(group.rel_path);
        try appendFmt(allocator, &buf, "pub const {s} = @import(\"{s}\");\n", .{ basename, group.rel_path });
    }

    return buf.toOwnedSlice(allocator);
}

// --- Function emitters ---

fn emitOneFunction(allocator: std.mem.Allocator, buf: *std.ArrayList(u8), q: introspect.TypedQuery, use_helper: bool) !void {
    const func_name = try toFuncName(allocator, q.name);
    defer allocator.free(func_name);
    const struct_name = try queryStructName(allocator, q.name, "Row");
    defer allocator.free(struct_name);

    const use_struct = q.params.len > params_struct_threshold;
    const params_struct_name: ?[]const u8 = if (use_struct)
        try queryStructName(allocator, q.name, "Params")
    else
        null;
    defer if (params_struct_name) |n| allocator.free(n);

    const needs_alloc = columnsNeedDupe(q.columns);

    // pub fn funcName(pool: *pg.Pool, [allocator: std.mem.Allocator,] ...) !?RowStruct {
    try appendFmt(allocator, buf, "pub fn {s}(pool: *pg.Pool", .{func_name});
    if (needs_alloc) try buf.appendSlice(allocator, ", allocator: std.mem.Allocator");
    try emitFuncParams(allocator, buf, q.params, params_struct_name, use_helper);
    try appendFmt(allocator, buf, ") !?{s} {{\n", .{struct_name});

    // if (try pool.row(\\SQL, .{params})) |row| {
    try buf.appendSlice(allocator, "    if (try pool.row(\n");
    try emitSqlLiteral(allocator, buf, q.sql, 8);
    try buf.appendSlice(allocator, "    , ");
    try emitParamsTuple(allocator, buf, q.params, use_struct);
    try buf.appendSlice(allocator, ")) |row| {\n");
    try buf.appendSlice(allocator, "        defer row.deinit();\n");

    // return .{ .field = row.get(...), ... };
    try buf.appendSlice(allocator, "        return .{\n");
    for (q.columns, 0..) |col, i| {
        try emitRowFieldAssignment(allocator, buf, col, i, "            ", use_helper);
    }
    try buf.appendSlice(allocator, "        };\n");
    try buf.appendSlice(allocator, "    }\n");
    try buf.appendSlice(allocator, "    return null;\n");
    try buf.appendSlice(allocator, "}\n\n");
}

fn emitManyFunction(allocator: std.mem.Allocator, buf: *std.ArrayList(u8), q: introspect.TypedQuery, use_helper: bool) !void {
    const func_name = try toFuncName(allocator, q.name);
    defer allocator.free(func_name);
    const struct_name = try queryStructName(allocator, q.name, "Row");
    defer allocator.free(struct_name);

    const use_struct = q.params.len > params_struct_threshold;
    const params_struct_name: ?[]const u8 = if (use_struct)
        try queryStructName(allocator, q.name, "Params")
    else
        null;
    defer if (params_struct_name) |n| allocator.free(n);

    // pub fn funcName(pool: *pg.Pool, allocator: std.mem.Allocator, ...) ![]RowStruct {
    try appendFmt(allocator, buf, "pub fn {s}(pool: *pg.Pool, allocator: std.mem.Allocator", .{func_name});
    try emitFuncParams(allocator, buf, q.params, params_struct_name, use_helper);
    try appendFmt(allocator, buf, ") ![]{s} {{\n", .{struct_name});

    // var result = try pool.query(\\SQL, .{params});
    try buf.appendSlice(allocator, "    var result = try pool.query(\n");
    try emitSqlLiteral(allocator, buf, q.sql, 8);
    try buf.appendSlice(allocator, "    , ");
    try emitParamsTuple(allocator, buf, q.params, use_struct);
    try buf.appendSlice(allocator, ");\n");
    try buf.appendSlice(allocator, "    defer result.deinit();\n\n");

    // var rows: std.ArrayList(RowStruct) = .empty;
    try appendFmt(allocator, buf, "    var rows: std.ArrayList({s}) = .empty;\n", .{struct_name});
    try buf.appendSlice(allocator, "    errdefer rows.deinit(allocator);\n\n");

    // while (try result.next()) |row| { ... }
    try buf.appendSlice(allocator, "    while (try result.next()) |row| {\n");
    try buf.appendSlice(allocator, "        try rows.append(allocator, .{\n");
    for (q.columns, 0..) |col, i| {
        try emitRowFieldAssignment(allocator, buf, col, i, "            ", use_helper);
    }
    try buf.appendSlice(allocator, "        });\n");
    try buf.appendSlice(allocator, "    }\n");
    try buf.appendSlice(allocator, "    return rows.toOwnedSlice(allocator);\n");
    try buf.appendSlice(allocator, "}\n\n");
}

fn emitExecFunction(allocator: std.mem.Allocator, buf: *std.ArrayList(u8), q: introspect.TypedQuery, use_helper: bool) !void {
    const func_name = try toFuncName(allocator, q.name);
    defer allocator.free(func_name);

    const use_struct = q.params.len > params_struct_threshold;
    const params_struct_name: ?[]const u8 = if (use_struct)
        try queryStructName(allocator, q.name, "Params")
    else
        null;
    defer if (params_struct_name) |n| allocator.free(n);

    // pub fn funcName(pool: *pg.Pool, ...) !void {
    try appendFmt(allocator, buf, "pub fn {s}(pool: *pg.Pool", .{func_name});
    try emitFuncParams(allocator, buf, q.params, params_struct_name, use_helper);
    try buf.appendSlice(allocator, ") !void {\n");

    // _ = try pool.exec(\\SQL, .{params});
    try buf.appendSlice(allocator, "    _ = try pool.exec(\n");
    try emitSqlLiteral(allocator, buf, q.sql, 8);
    try buf.appendSlice(allocator, "    , ");
    try emitParamsTuple(allocator, buf, q.params, use_struct);
    try buf.appendSlice(allocator, ");\n");
    try buf.appendSlice(allocator, "}\n\n");
}

fn emitExecRowsFunction(allocator: std.mem.Allocator, buf: *std.ArrayList(u8), q: introspect.TypedQuery, use_helper: bool) !void {
    const func_name = try toFuncName(allocator, q.name);
    defer allocator.free(func_name);

    const use_struct = q.params.len > params_struct_threshold;
    const params_struct_name: ?[]const u8 = if (use_struct)
        try queryStructName(allocator, q.name, "Params")
    else
        null;
    defer if (params_struct_name) |n| allocator.free(n);

    // pub fn funcName(pool: *pg.Pool, ...) !?usize {
    try appendFmt(allocator, buf, "pub fn {s}(pool: *pg.Pool", .{func_name});
    try emitFuncParams(allocator, buf, q.params, params_struct_name, use_helper);
    try buf.appendSlice(allocator, ") !?usize {\n");

    // return pool.exec(\\SQL, .{params});
    try buf.appendSlice(allocator, "    return pool.exec(\n");
    try emitSqlLiteral(allocator, buf, q.sql, 8);
    try buf.appendSlice(allocator, "    , ");
    try emitParamsTuple(allocator, buf, q.params, use_struct);
    try buf.appendSlice(allocator, ");\n");
    try buf.appendSlice(allocator, "}\n\n");
}

// --- Helpers ---

/// Emit function parameters (after pool and allocator).
fn emitFuncParams(allocator: std.mem.Allocator, buf: *std.ArrayList(u8), params: []const introspect.Param, params_struct_name: ?[]const u8, use_helper: bool) !void {
    if (params_struct_name) |name| {
        try buf.appendSlice(allocator, ", params: ");
        try buf.appendSlice(allocator, name);
    } else {
        for (params) |param| {
            try buf.appendSlice(allocator, ", ");
            try buf.appendSlice(allocator, param.name);
            try buf.appendSlice(allocator, ": ");
            try appendPgFieldType(allocator, buf, param.zig_type, use_helper);
        }
    }
}

/// Emit the params tuple: .{param1, param2, ...}
fn emitParamsTuple(allocator: std.mem.Allocator, buf: *std.ArrayList(u8), params: []const introspect.Param, use_struct: bool) !void {
    try buf.appendSlice(allocator, ".{");
    for (params, 0..) |param, i| {
        if (i > 0) try buf.appendSlice(allocator, ", ");
        if (use_struct) try buf.appendSlice(allocator, "params.");
        try buf.appendSlice(allocator, param.name);
    }
    try buf.appendSlice(allocator, "}");
}

/// Emit SQL as a Zig multiline string literal using \\ prefixed lines.
fn emitSqlLiteral(allocator: std.mem.Allocator, buf: *std.ArrayList(u8), sql: []const u8, indent: usize) !void {
    var lines = std.mem.splitScalar(u8, sql, '\n');
    var first = true;
    while (lines.next()) |line| {
        if (!first) try buf.append(allocator, '\n');
        first = false;
        // Emit indent spaces
        for (0..indent) |_| try buf.append(allocator, ' ');
        try buf.appendSlice(allocator, "\\\\");
        // Strip \r from line endings
        const clean = std.mem.trimRight(u8, line, "\r");
        if (clean.len > 0) {
            try buf.append(allocator, ' ');
            try buf.appendSlice(allocator, clean);
        }
    }
    try buf.append(allocator, '\n');
}

/// Emit a row field assignment: .name = row.get(T, idx), with dupe for strings.
fn emitRowFieldAssignment(allocator: std.mem.Allocator, buf: *std.ArrayList(u8), col: introspect.Column, index: usize, indent: []const u8, use_helper: bool) !void {
    try buf.appendSlice(allocator, indent);
    try buf.append(allocator, '.');
    try buf.appendSlice(allocator, col.name);
    try buf.appendSlice(allocator, " = ");

    const is_enum = switch (col.zig_type) {
        .pg_enum => true,
        else => false,
    };
    const needs_dupe = typeNeedsDupe(col.zig_type);
    const pg_type = pgGetTypeName(col.zig_type);
    const prefix: []const u8 = if (use_helper) "helper." else "";

    if (col.nullable and is_enum) {
        const pascal = try snakeToPascal(allocator, col.zig_type.pg_enum.name);
        defer allocator.free(pascal);
        try appendFmt(allocator, buf, "if (row.get(?[]u8, {d})) |v| (std.meta.stringToEnum({s}{s}, v) orelse return error.InvalidEnumValue) else null", .{ index, prefix, pascal });
    } else if (col.nullable and needs_dupe) {
        try appendFmt(allocator, buf, "if (row.get(?{s}, {d})) |v| try allocator.dupe(u8, v) else null", .{ pg_type, index });
    } else if (col.nullable) {
        try appendFmt(allocator, buf, "row.get(?{s}, {d})", .{ pg_type, index });
    } else if (is_enum) {
        const pascal = try snakeToPascal(allocator, col.zig_type.pg_enum.name);
        defer allocator.free(pascal);
        try appendFmt(allocator, buf, "std.meta.stringToEnum({s}{s}, row.get([]u8, {d})) orelse return error.InvalidEnumValue", .{ prefix, pascal, index });
    } else if (needs_dupe) {
        try appendFmt(allocator, buf, "try allocator.dupe(u8, row.get({s}, {d}))", .{ pg_type, index });
    } else {
        try appendFmt(allocator, buf, "row.get({s}, {d})", .{ pg_type, index });
    }

    try buf.appendSlice(allocator, ",\n");
}

/// Whether any column in a result set needs allocator.dupe.
fn columnsNeedDupe(columns: []const introspect.Column) bool {
    for (columns) |col| {
        if (typeNeedsDupe(col.zig_type)) return true;
    }
    return false;
}

/// Whether a type needs allocator.dupe when reading from pg.zig row.
fn typeNeedsDupe(zig_type: types.ZigType) bool {
    return switch (zig_type) {
        .text, .bytea, .uuid, .json, .pg_enum => true,
        .optional => |inner| typeNeedsDupe(inner.*),
        .unknown => true,
        else => false,
    };
}

/// Get the pg.zig row.get type name for a ZigType.
fn pgGetTypeName(zig_type: types.ZigType) []const u8 {
    return switch (zig_type) {
        .bool_type => "bool",
        .i16_type => "i16",
        .i32_type => "i32",
        .i64_type => "i64",
        .f32_type => "f32",
        .f64_type => "f64",
        .text, .bytea, .uuid, .json, .pg_enum => "[]u8",
        .timestamp => "i64",
        .date => "i32",
        .time => "i64",
        .optional => |inner| pgGetTypeName(inner.*),
        .array => "[]u8",
        .unknown => "[]u8",
    };
}

/// Append the pg.zig-compatible field type for struct definitions.
fn appendPgFieldType(allocator: std.mem.Allocator, buf: *std.ArrayList(u8), zig_type: types.ZigType, use_helper: bool) !void {
    switch (zig_type) {
        .optional => |inner| {
            try buf.append(allocator, '?');
            try appendPgFieldType(allocator, buf, inner.*, use_helper);
        },
        .array => |inner| {
            try buf.appendSlice(allocator, "[]const ");
            try appendPgFieldType(allocator, buf, inner.*, use_helper);
        },
        .pg_enum => |info| {
            if (use_helper) try buf.appendSlice(allocator, "helper.");
            const pascal = try snakeToPascal(allocator, info.name);
            defer allocator.free(pascal);
            try buf.appendSlice(allocator, pascal);
        },
        .timestamp => {
            if (use_helper) {
                try buf.appendSlice(allocator, "helper.Timestamp");
            } else {
                try buf.appendSlice(allocator, "Timestamp");
            }
        },
        .uuid => try buf.appendSlice(allocator, "[]const u8"),
        .date => try buf.appendSlice(allocator, "i32"),
        .time => try buf.appendSlice(allocator, "i64"),
        else => try buf.appendSlice(allocator, zig_type.zigTypeName()),
    }
}

fn scanTypeNeeds(
    zig_type: types.ZigType,
    needs_timestamp: *bool,
    enum_types: *std.StringHashMap(types.ZigType.EnumInfo),
) !void {
    switch (zig_type) {
        .timestamp => needs_timestamp.* = true,
        .pg_enum => |info| try enum_types.put(info.name, info),
        .optional => |inner| try scanTypeNeeds(inner.*, needs_timestamp, enum_types),
        .array => |inner| try scanTypeNeeds(inner.*, needs_timestamp, enum_types),
        else => {},
    }
}

/// Append formatted text to an ArrayList(u8).
fn appendFmt(allocator: std.mem.Allocator, buf: *std.ArrayList(u8), comptime fmt: []const u8, args: anytype) !void {
    const s = try std.fmt.allocPrint(allocator, fmt, args);
    defer allocator.free(s);
    try buf.appendSlice(allocator, s);
}

/// Convert a query name to a PascalCase struct name with suffix.
/// Handles both snake_case (find_user) and PascalCase (FindUser) input.
fn queryStructName(allocator: std.mem.Allocator, name: []const u8, suffix: []const u8) ![]const u8 {
    // If name already starts with uppercase, assume PascalCase — use directly
    if (name.len > 0 and std.ascii.isUpper(name[0])) {
        return std.fmt.allocPrint(allocator, "{s}{s}", .{ name, suffix });
    }
    const pascal = try snakeToPascal(allocator, name);
    defer allocator.free(pascal);
    return std.fmt.allocPrint(allocator, "{s}{s}", .{ pascal, suffix });
}

/// Derive a function name from a query name.
/// Handles both snake_case (find_user_by_id → findUserById)
/// and PascalCase (FindUserById → findUserById).
fn toFuncName(allocator: std.mem.Allocator, name: []const u8) ![]const u8 {
    if (name.len == 0) return allocator.dupe(u8, name);

    // If first char is uppercase, it's PascalCase — just lowercase the first char
    if (std.ascii.isUpper(name[0])) {
        const result = try allocator.dupe(u8, name);
        result[0] = std.ascii.toLower(name[0]);
        return result;
    }

    // Otherwise it's snake_case — convert to camelCase
    return snakeToCamel(allocator, name);
}

/// Convert snake_case to PascalCase.
pub fn snakeToPascal(allocator: std.mem.Allocator, input: []const u8) ![]const u8 {
    var result: std.ArrayList(u8) = .empty;
    errdefer result.deinit(allocator);

    var capitalize_next = true;
    for (input) |c| {
        if (c == '_') {
            capitalize_next = true;
        } else {
            if (capitalize_next) {
                try result.append(allocator, std.ascii.toUpper(c));
                capitalize_next = false;
            } else {
                try result.append(allocator, c);
            }
        }
    }

    return result.toOwnedSlice(allocator);
}

/// Convert snake_case to camelCase.
pub fn snakeToCamel(allocator: std.mem.Allocator, input: []const u8) ![]const u8 {
    var result: std.ArrayList(u8) = .empty;
    errdefer result.deinit(allocator);

    var capitalize_next = false;
    for (input) |c| {
        if (c == '_') {
            capitalize_next = true;
        } else {
            if (capitalize_next) {
                try result.append(allocator, std.ascii.toUpper(c));
                capitalize_next = false;
            } else {
                try result.append(allocator, c);
            }
        }
    }

    return result.toOwnedSlice(allocator);
}

/// Sanitize an enum variant name to be a valid Zig identifier.
fn sanitizeEnumVariant(allocator: std.mem.Allocator, variant: []const u8) ![]const u8 {
    if (variant.len == 0) return allocator.dupe(u8, "@\"\"");

    var needs_escape = false;
    if (!std.ascii.isAlphabetic(variant[0]) and variant[0] != '_') {
        needs_escape = true;
    }
    if (!needs_escape) {
        for (variant) |c| {
            if (!std.ascii.isAlphanumeric(c) and c != '_') {
                needs_escape = true;
                break;
            }
        }
    }

    if (needs_escape) {
        return std.fmt.allocPrint(allocator, "@\"{s}\"", .{variant});
    }
    return allocator.dupe(u8, variant);
}

// --- Tests ---

test "snakeToPascal" {
    const allocator = std.testing.allocator;

    {
        const result = try snakeToPascal(allocator, "find_user_by_id");
        defer allocator.free(result);
        try std.testing.expectEqualStrings("FindUserById", result);
    }
    {
        const result = try snakeToPascal(allocator, "get_all");
        defer allocator.free(result);
        try std.testing.expectEqualStrings("GetAll", result);
    }
    {
        const result = try snakeToPascal(allocator, "user");
        defer allocator.free(result);
        try std.testing.expectEqualStrings("User", result);
    }
}

test "snakeToCamel" {
    const allocator = std.testing.allocator;

    {
        const result = try snakeToCamel(allocator, "find_user_by_id");
        defer allocator.free(result);
        try std.testing.expectEqualStrings("findUserById", result);
    }
    {
        const result = try snakeToCamel(allocator, "list_users");
        defer allocator.free(result);
        try std.testing.expectEqualStrings("listUsers", result);
    }
    {
        const result = try snakeToCamel(allocator, "user");
        defer allocator.free(result);
        try std.testing.expectEqualStrings("user", result);
    }
}

test "toFuncName from PascalCase" {
    const allocator = std.testing.allocator;

    {
        const result = try toFuncName(allocator, "FindUserById");
        defer allocator.free(result);
        try std.testing.expectEqualStrings("findUserById", result);
    }
    {
        const result = try toFuncName(allocator, "DeleteUser");
        defer allocator.free(result);
        try std.testing.expectEqualStrings("deleteUser", result);
    }
    {
        const result = try toFuncName(allocator, "ListUsers");
        defer allocator.free(result);
        try std.testing.expectEqualStrings("listUsers", result);
    }
}

test "toFuncName from snake_case" {
    const allocator = std.testing.allocator;

    {
        const result = try toFuncName(allocator, "find_user_by_id");
        defer allocator.free(result);
        try std.testing.expectEqualStrings("findUserById", result);
    }
    {
        const result = try toFuncName(allocator, "delete_user");
        defer allocator.free(result);
        try std.testing.expectEqualStrings("deleteUser", result);
    }
}

test "queryStructName from PascalCase" {
    const allocator = std.testing.allocator;

    {
        const result = try queryStructName(allocator, "FindUserById", "Row");
        defer allocator.free(result);
        try std.testing.expectEqualStrings("FindUserByIdRow", result);
    }
    {
        const result = try queryStructName(allocator, "find_user", "Row");
        defer allocator.free(result);
        try std.testing.expectEqualStrings("FindUserRow", result);
    }
}

test "generate empty queries" {
    const allocator = std.testing.allocator;
    const result = try generate(allocator, &.{}, null);
    defer allocator.free(result);
    try std.testing.expect(std.mem.startsWith(u8, result, header));
}

test "generate many query" {
    const allocator = std.testing.allocator;

    const columns = try allocator.alloc(introspect.Column, 2);
    defer allocator.free(columns);
    columns[0] = .{
        .name = "id",
        .zig_type = .i32_type,
        .nullable = false,
        .table_oid = 0,
        .column_attr = 0,
    };
    columns[1] = .{
        .name = "name",
        .zig_type = .text,
        .nullable = true,
        .table_oid = 0,
        .column_attr = 0,
    };

    const queries = [_]introspect.TypedQuery{.{
        .name = "FindUser",
        .file_path = "sql/find_user.sql",
        .sql = "SELECT id, name FROM users WHERE id = $1",
        .comment = null,
        .kind = .many,
        .params = &.{},
        .columns = columns,
    }};

    const result = try generate(allocator, &queries, null);
    defer allocator.free(result);

    try std.testing.expect(std.mem.indexOf(u8, result, "FindUserRow") != null);
    try std.testing.expect(std.mem.indexOf(u8, result, "id: i32") != null);
    try std.testing.expect(std.mem.indexOf(u8, result, "name: ?[]const u8") != null);
    try std.testing.expect(std.mem.indexOf(u8, result, "pub fn findUser(") != null);
    try std.testing.expect(std.mem.indexOf(u8, result, "@import(\"pg\")") != null);
    try std.testing.expect(std.mem.indexOf(u8, result, "pool.query(") != null);
}

test "generate one query" {
    const allocator = std.testing.allocator;

    const params = try allocator.alloc(introspect.Param, 1);
    defer allocator.free(params);
    params[0] = .{ .index = 0, .name = "id", .zig_type = .i32_type };

    const columns = try allocator.alloc(introspect.Column, 1);
    defer allocator.free(columns);
    columns[0] = .{
        .name = "email",
        .zig_type = .text,
        .nullable = false,
        .table_oid = 0,
        .column_attr = 0,
    };

    const queries = [_]introspect.TypedQuery{.{
        .name = "GetEmail",
        .file_path = "sql/get_email.sql",
        .sql = "SELECT email FROM users WHERE id = $1",
        .comment = null,
        .kind = .one,
        .params = params,
        .columns = columns,
    }};

    const result = try generate(allocator, &queries, null);
    defer allocator.free(result);

    try std.testing.expect(std.mem.indexOf(u8, result, "pub fn getEmail(") != null);
    try std.testing.expect(std.mem.indexOf(u8, result, "pool.row(") != null);
    try std.testing.expect(std.mem.indexOf(u8, result, "defer row.deinit()") != null);
    try std.testing.expect(std.mem.indexOf(u8, result, "return null") != null);
    try std.testing.expect(std.mem.indexOf(u8, result, "allocator.dupe(u8,") != null);
}

test "generate exec query" {
    const allocator = std.testing.allocator;

    const params = try allocator.alloc(introspect.Param, 1);
    defer allocator.free(params);
    params[0] = .{ .index = 0, .name = "id", .zig_type = .i32_type };

    const queries = [_]introspect.TypedQuery{.{
        .name = "DeleteUser",
        .file_path = "sql/delete_user.sql",
        .sql = "DELETE FROM users WHERE id = $1",
        .comment = null,
        .kind = .exec,
        .params = params,
        .columns = &.{},
    }};

    const result = try generate(allocator, &queries, null);
    defer allocator.free(result);

    try std.testing.expect(std.mem.indexOf(u8, result, "pub fn deleteUser(") != null);
    try std.testing.expect(std.mem.indexOf(u8, result, "pool.exec(") != null);
    try std.testing.expect(std.mem.indexOf(u8, result, ") !void {") != null);
    try std.testing.expect(std.mem.indexOf(u8, result, "_ = try pool.exec(") != null);
}

test "generate execrows query" {
    const allocator = std.testing.allocator;

    const params = try allocator.alloc(introspect.Param, 1);
    defer allocator.free(params);
    params[0] = .{ .index = 0, .name = "id", .zig_type = .i32_type };

    const queries = [_]introspect.TypedQuery{.{
        .name = "SoftDeleteUser",
        .file_path = "sql/soft_delete_user.sql",
        .sql = "UPDATE users SET active = false WHERE id = $1",
        .comment = null,
        .kind = .execrows,
        .params = params,
        .columns = &.{},
    }};

    const result = try generate(allocator, &queries, null);
    defer allocator.free(result);

    try std.testing.expect(std.mem.indexOf(u8, result, "pub fn softDeleteUser(") != null);
    try std.testing.expect(std.mem.indexOf(u8, result, "pool.exec(") != null);
    try std.testing.expect(std.mem.indexOf(u8, result, ") !?usize {") != null);
    try std.testing.expect(std.mem.indexOf(u8, result, "return pool.exec(") != null);
}

test "sanitizeEnumVariant" {
    const allocator = std.testing.allocator;

    {
        const result = try sanitizeEnumVariant(allocator, "active");
        defer allocator.free(result);
        try std.testing.expectEqualStrings("active", result);
    }
    {
        const result = try sanitizeEnumVariant(allocator, "in-progress");
        defer allocator.free(result);
        try std.testing.expectEqualStrings("@\"in-progress\"", result);
    }
}

test "generated code is valid Zig syntax" {
    const allocator = std.testing.allocator;

    // Build test params and columns covering all 4 query kinds
    const params_1 = try allocator.alloc(introspect.Param, 1);
    defer allocator.free(params_1);
    params_1[0] = .{ .index = 0, .name = "id", .zig_type = .i32_type };

    const cols_one = try allocator.alloc(introspect.Column, 3);
    defer allocator.free(cols_one);
    cols_one[0] = .{ .name = "id", .zig_type = .i32_type, .nullable = false, .table_oid = 0, .column_attr = 0 };
    cols_one[1] = .{ .name = "name", .zig_type = .text, .nullable = false, .table_oid = 0, .column_attr = 0 };
    cols_one[2] = .{ .name = "bio", .zig_type = .text, .nullable = true, .table_oid = 0, .column_attr = 0 };

    const cols_many = try allocator.alloc(introspect.Column, 2);
    defer allocator.free(cols_many);
    cols_many[0] = .{ .name = "user_id", .zig_type = .i32_type, .nullable = false, .table_oid = 0, .column_attr = 0 };
    cols_many[1] = .{ .name = "title", .zig_type = .text, .nullable = false, .table_oid = 0, .column_attr = 0 };

    // 4 params — triggers Params struct generation
    const params_4 = try allocator.alloc(introspect.Param, 4);
    defer allocator.free(params_4);
    params_4[0] = .{ .index = 0, .name = "id", .zig_type = .i32_type };
    params_4[1] = .{ .index = 1, .name = "name", .zig_type = .text };
    params_4[2] = .{ .index = 2, .name = "email", .zig_type = .text };
    params_4[3] = .{ .index = 3, .name = "is_active", .zig_type = .bool_type };

    const queries = [_]introspect.TypedQuery{
        .{
            .name = "GetUserById",
            .file_path = "sql/select.sql",
            .sql = "SELECT id, name, bio\nFROM users\nWHERE id = $1",
            .comment = "Find a user by primary key.",
            .kind = .one,
            .params = params_1,
            .columns = cols_one,
        },
        .{
            .name = "ListPostsByUser",
            .file_path = "sql/select.sql",
            .sql = "SELECT p.user_id, p.title\nFROM posts p\nJOIN users u ON u.id = p.user_id\nWHERE u.id = $1",
            .comment = "List posts for a given user.",
            .kind = .many,
            .params = params_1,
            .columns = cols_many,
        },
        .{
            .name = "DeletePost",
            .file_path = "sql/delete.sql",
            .sql = "DELETE FROM posts WHERE id = $1",
            .comment = null,
            .kind = .exec,
            .params = params_1,
            .columns = &.{},
        },
        .{
            .name = "DeactivateUser",
            .file_path = "sql/update.sql",
            .sql = "UPDATE users SET is_active = false WHERE id = $1",
            .comment = null,
            .kind = .execrows,
            .params = params_1,
            .columns = &.{},
        },
        .{
            .name = "UpdateUser",
            .file_path = "sql/update.sql",
            .sql = "UPDATE users SET name = $2, email = $3, is_active = $4 WHERE id = $1\nRETURNING id, name, bio",
            .comment = "Update a user's profile fields.",
            .kind = .one,
            .params = params_4,
            .columns = cols_one,
        },
    };

    const result = try generate(allocator, &queries, null);
    defer allocator.free(result);

    // Verify Params struct is generated for 4+ params
    try std.testing.expect(std.mem.indexOf(u8, result, "pub const UpdateUserParams = struct {") != null);
    try std.testing.expect(std.mem.indexOf(u8, result, "params: UpdateUserParams") != null);
    try std.testing.expect(std.mem.indexOf(u8, result, "params.id") != null);
    try std.testing.expect(std.mem.indexOf(u8, result, "params.name") != null);

    // Verify no Params struct for queries with <=3 params
    try std.testing.expect(std.mem.indexOf(u8, result, "GetUserByIdParams") == null);
    try std.testing.expect(std.mem.indexOf(u8, result, "DeletePostParams") == null);

    // Parse as Zig AST — zero errors means valid syntax
    const result_z: [:0]const u8 = try allocator.dupeZ(u8, result);
    defer allocator.free(result_z);
    var ast = try std.zig.Ast.parse(allocator, result_z, .zig);
    defer ast.deinit(allocator);
    try std.testing.expectEqual(@as(usize, 0), ast.errors.len);
}
