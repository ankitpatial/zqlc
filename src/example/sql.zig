// Code generated by zqlc. DO NOT EDIT.

const std = @import("std");
const pg = @import("pg");

pub const Timestamp = i64;

/// Find a single user by their primary key.
pub const FindUserByIdRow = struct {
    id: i32,
    name: []const u8,
    email: []const u8,
    bio: ?[]const u8,
    is_active: bool,
    created_at: Timestamp,
};

pub fn findUserById(pool: *pg.Pool, allocator: std.mem.Allocator, id: i32) !?FindUserByIdRow {
    if (try pool.row(
        \\ SELECT id, name, email, bio, is_active, created_at
        \\ FROM users
        \\ WHERE id = $1
    , .{id})) |row| {
        defer row.deinit();
        return .{
            .id = row.get(i32, 0),
            .name = try allocator.dupe(u8, row.get([]u8, 1)),
            .email = try allocator.dupe(u8, row.get([]u8, 2)),
            .bio = if (row.get(?[]u8, 3)) |v| try allocator.dupe(u8, v) else null,
            .is_active = row.get(bool, 4),
            .created_at = row.get(i64, 5),
        };
    }
    return null;
}

/// List all users ordered by creation date (newest first).
pub const ListUsersRow = struct {
    id: i32,
    name: []const u8,
    email: []const u8,
    bio: ?[]const u8,
    is_active: bool,
    created_at: Timestamp,
};

pub fn listUsers(pool: *pg.Pool, allocator: std.mem.Allocator) ![]ListUsersRow {
    var result = try pool.query(
        \\ SELECT id, name, email, bio, is_active, created_at
        \\ FROM users
        \\ ORDER BY created_at DESC
    , .{});
    defer result.deinit();

    var rows: std.ArrayList(ListUsersRow) = .empty;
    errdefer rows.deinit(allocator);

    while (try result.next()) |row| {
        try rows.append(allocator, .{
            .id = row.get(i32, 0),
            .name = try allocator.dupe(u8, row.get([]u8, 1)),
            .email = try allocator.dupe(u8, row.get([]u8, 2)),
            .bio = if (row.get(?[]u8, 3)) |v| try allocator.dupe(u8, v) else null,
            .is_active = row.get(bool, 4),
            .created_at = row.get(i64, 5),
        });
    }
    return rows.toOwnedSlice(allocator);
}

/// Get a post along with its author name.
pub const GetPostWithAuthorRow = struct {
    id: i32,
    title: []const u8,
    body: []const u8,
    published: bool,
    created_at: Timestamp,
    author_name: []const u8,
};

pub fn getPostWithAuthor(pool: *pg.Pool, allocator: std.mem.Allocator, id: i32) !?GetPostWithAuthorRow {
    if (try pool.row(
        \\ SELECT p.id, p.title, p.body, p.published, p.created_at,
        \\        u.name AS author_name
        \\ FROM posts p
        \\ JOIN users u ON u.id = p.user_id
        \\ WHERE p.id = $1
    , .{id})) |row| {
        defer row.deinit();
        return .{
            .id = row.get(i32, 0),
            .title = try allocator.dupe(u8, row.get([]u8, 1)),
            .body = try allocator.dupe(u8, row.get([]u8, 2)),
            .published = row.get(bool, 3),
            .created_at = row.get(i64, 4),
            .author_name = try allocator.dupe(u8, row.get([]u8, 5)),
        };
    }
    return null;
}

/// List comments on a post with commenter names.
pub const ListPostCommentsRow = struct {
    id: i32,
    body: []const u8,
    created_at: Timestamp,
    commenter_name: []const u8,
};

pub fn listPostComments(pool: *pg.Pool, allocator: std.mem.Allocator, post_id: i32) ![]ListPostCommentsRow {
    var result = try pool.query(
        \\ SELECT c.id, c.body, c.created_at,
        \\        u.name AS commenter_name
        \\ FROM comments c
        \\ JOIN users u ON u.id = c.user_id
        \\ WHERE c.post_id = $1
        \\ ORDER BY c.created_at
    , .{post_id});
    defer result.deinit();

    var rows: std.ArrayList(ListPostCommentsRow) = .empty;
    errdefer rows.deinit(allocator);

    while (try result.next()) |row| {
        try rows.append(allocator, .{
            .id = row.get(i32, 0),
            .body = try allocator.dupe(u8, row.get([]u8, 1)),
            .created_at = row.get(i64, 2),
            .commenter_name = try allocator.dupe(u8, row.get([]u8, 3)),
        });
    }
    return rows.toOwnedSlice(allocator);
}

/// Count posts per user using GROUP BY.
pub const CountPostsByUserRow = struct {
    user_id: i32,
    name: []const u8,
    post_count: i32,
};

pub fn countPostsByUser(pool: *pg.Pool, allocator: std.mem.Allocator) ![]CountPostsByUserRow {
    var result = try pool.query(
        \\ SELECT u.id AS user_id, u.name,
        \\        COUNT(p.id)::int AS post_count
        \\ FROM users u
        \\ LEFT JOIN posts p ON p.user_id = u.id
        \\ GROUP BY u.id, u.name
        \\ ORDER BY post_count DESC
    , .{});
    defer result.deinit();

    var rows: std.ArrayList(CountPostsByUserRow) = .empty;
    errdefer rows.deinit(allocator);

    while (try result.next()) |row| {
        try rows.append(allocator, .{
            .user_id = row.get(i32, 0),
            .name = try allocator.dupe(u8, row.get([]u8, 1)),
            .post_count = row.get(i32, 2),
        });
    }
    return rows.toOwnedSlice(allocator);
}

/// List posts that have a given tag (many-to-many through post_tags).
pub const ListPostsByTagRow = struct {
    id: i32,
    title: []const u8,
    created_at: Timestamp,
    author_name: []const u8,
};

pub fn listPostsByTag(pool: *pg.Pool, allocator: std.mem.Allocator, name: []const u8) ![]ListPostsByTagRow {
    var result = try pool.query(
        \\ SELECT p.id, p.title, p.created_at,
        \\        u.name AS author_name
        \\ FROM posts p
        \\ JOIN post_tags pt ON pt.post_id = p.id
        \\ JOIN tags t ON t.id = pt.tag_id
        \\ JOIN users u ON u.id = p.user_id
        \\ WHERE t.name = $1
        \\ ORDER BY p.created_at DESC
    , .{name});
    defer result.deinit();

    var rows: std.ArrayList(ListPostsByTagRow) = .empty;
    errdefer rows.deinit(allocator);

    while (try result.next()) |row| {
        try rows.append(allocator, .{
            .id = row.get(i32, 0),
            .title = try allocator.dupe(u8, row.get([]u8, 1)),
            .created_at = row.get(i64, 2),
            .author_name = try allocator.dupe(u8, row.get([]u8, 3)),
        });
    }
    return rows.toOwnedSlice(allocator);
}

/// Insert a new user and return the created row.
pub const CreateUserRow = struct {
    id: i32,
    name: []const u8,
    email: []const u8,
    bio: ?[]const u8,
    is_active: bool,
    created_at: Timestamp,
};

pub fn createUser(pool: *pg.Pool, allocator: std.mem.Allocator, name: []const u8, email: []const u8, bio: []const u8) !?CreateUserRow {
    if (try pool.row(
        \\ INSERT INTO users (name, email, bio)
        \\ VALUES ($1, $2, $3)
        \\ RETURNING id, name, email, bio, is_active, created_at
    , .{ name, email, bio })) |row| {
        defer row.deinit();
        return .{
            .id = row.get(i32, 0),
            .name = try allocator.dupe(u8, row.get([]u8, 1)),
            .email = try allocator.dupe(u8, row.get([]u8, 2)),
            .bio = if (row.get(?[]u8, 3)) |v| try allocator.dupe(u8, v) else null,
            .is_active = row.get(bool, 4),
            .created_at = row.get(i64, 5),
        };
    }
    return null;
}

/// Create a new post for a user.
pub const CreatePostRow = struct {
    id: i32,
    user_id: i32,
    title: []const u8,
    body: []const u8,
    published: bool,
    created_at: Timestamp,
};

pub fn createPost(pool: *pg.Pool, allocator: std.mem.Allocator, user_id: i32, title: []const u8, body: []const u8) !?CreatePostRow {
    if (try pool.row(
        \\ INSERT INTO posts (user_id, title, body)
        \\ VALUES ($1, $2, $3)
        \\ RETURNING id, user_id, title, body, published, created_at
    , .{ user_id, title, body })) |row| {
        defer row.deinit();
        return .{
            .id = row.get(i32, 0),
            .user_id = row.get(i32, 1),
            .title = try allocator.dupe(u8, row.get([]u8, 2)),
            .body = try allocator.dupe(u8, row.get([]u8, 3)),
            .published = row.get(bool, 4),
            .created_at = row.get(i64, 5),
        };
    }
    return null;
}

/// Add a comment to a post.
pub const AddCommentRow = struct {
    id: i32,
    post_id: i32,
    user_id: i32,
    body: []const u8,
    created_at: Timestamp,
};

pub fn addComment(pool: *pg.Pool, allocator: std.mem.Allocator, post_id: i32, user_id: i32, body: []const u8) !?AddCommentRow {
    if (try pool.row(
        \\ INSERT INTO comments (post_id, user_id, body)
        \\ VALUES ($1, $2, $3)
        \\ RETURNING id, post_id, user_id, body, created_at
    , .{ post_id, user_id, body })) |row| {
        defer row.deinit();
        return .{
            .id = row.get(i32, 0),
            .post_id = row.get(i32, 1),
            .user_id = row.get(i32, 2),
            .body = try allocator.dupe(u8, row.get([]u8, 3)),
            .created_at = row.get(i64, 4),
        };
    }
    return null;
}

/// Associate a tag with a post.
pub fn tagPost(pool: *pg.Pool, post_id: i32, tag_id: i32) !void {
    _ = try pool.exec(
        \\ INSERT INTO post_tags (post_id, tag_id)
        \\ VALUES ($1, $2)
        \\ ON CONFLICT DO NOTHING
    , .{ post_id, tag_id });
}

/// Update a user's email address and return the updated row.
pub const UpdateUserEmailRow = struct {
    id: i32,
    name: []const u8,
    email: []const u8,
};

pub fn updateUserEmail(pool: *pg.Pool, allocator: std.mem.Allocator, id: i32, email: []const u8) !?UpdateUserEmailRow {
    if (try pool.row(
        \\ UPDATE users
        \\ SET email = $2
        \\ WHERE id = $1
        \\ RETURNING id, name, email
    , .{ id, email })) |row| {
        defer row.deinit();
        return .{
            .id = row.get(i32, 0),
            .name = try allocator.dupe(u8, row.get([]u8, 1)),
            .email = try allocator.dupe(u8, row.get([]u8, 2)),
        };
    }
    return null;
}

/// Update a user's profile fields.
pub const UpdateUserRow = struct {
    id: i32,
    name: []const u8,
    email: []const u8,
    bio: ?[]const u8,
    is_active: bool,
    created_at: Timestamp,
};

pub const UpdateUserParams = struct {
    id: i32,
    name: []const u8,
    email: []const u8,
    bio: []const u8,
    is_active: bool,
};

pub fn updateUser(pool: *pg.Pool, allocator: std.mem.Allocator, params: UpdateUserParams) !?UpdateUserRow {
    if (try pool.row(
        \\ UPDATE users
        \\ SET name = $2, email = $3, bio = $4, is_active = $5
        \\ WHERE id = $1
        \\ RETURNING id, name, email, bio, is_active, created_at
    , .{ params.id, params.name, params.email, params.bio, params.is_active })) |row| {
        defer row.deinit();
        return .{
            .id = row.get(i32, 0),
            .name = try allocator.dupe(u8, row.get([]u8, 1)),
            .email = try allocator.dupe(u8, row.get([]u8, 2)),
            .bio = if (row.get(?[]u8, 3)) |v| try allocator.dupe(u8, v) else null,
            .is_active = row.get(bool, 4),
            .created_at = row.get(i64, 5),
        };
    }
    return null;
}

/// Mark a post as published.
pub fn publishPost(pool: *pg.Pool, id: i32) !void {
    _ = try pool.exec(
        \\ UPDATE posts
        \\ SET published = true
        \\ WHERE id = $1
    , .{id});
}

/// Deactivate a user account. Returns affected row count.
pub fn deactivateUser(pool: *pg.Pool, id: i32) !?usize {
    return pool.exec(
        \\ UPDATE users
        \\ SET is_active = false
        \\ WHERE id = $1
    , .{id});
}

/// Delete a post by ID.
pub fn deletePost(pool: *pg.Pool, id: i32) !void {
    _ = try pool.exec(
        \\ DELETE FROM posts
        \\ WHERE id = $1
    , .{id});
}

/// Remove a tag from a post.
pub fn removePostTag(pool: *pg.Pool, post_id: i32, tag_id: i32) !void {
    _ = try pool.exec(
        \\ DELETE FROM post_tags
        \\ WHERE post_id = $1 AND tag_id = $2
    , .{ post_id, tag_id });
}
